/**
 *Submitted for verification at polygonscan.com on 2023-02-08
*/

pragma solidity ^0.8.13;
// SPDX-License-Identifier: MIT


struct AuthRequest {
  string prompt;
  uint256 createdAt;
  string id;
}

bytes32 constant AUTHREQUEST_TYPEHASH = keccak256("AuthRequest(string prompt,uint256 createdAt,string id)");
// BEGIN EIP712 AUTOGENERATED SETUP
struct EIP712Domain {
    string name;
    string version;
    uint256 chainId;
    address verifyingContract;
}

bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(
    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
);

contract EIP712Decoder {

  /**
  * @dev Recover signer address from a message by using their signature
  * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
  * @param sig bytes signature, the signature is generated using web3.eth.sign()
  */
  function recover(bytes32 hash, bytes memory sig) internal pure returns (address) {
    bytes32 r;
    bytes32 s;
    uint8 v;

    //Check the signature length
    if (sig.length != 65) {
      return (address(0));
    }

    // Divide the signature in r, s and v variables
    assembly {
      r := mload(add(sig, 32))
      s := mload(add(sig, 64))
      v := byte(0, mload(add(sig, 96)))
    }
// Version of signature should be 27 or 28, but 0 and 1 are also possible versions
    if (v < 27) {
      v += 27;
    }

    // If the version is correct return the signer address
    if (v != 27 && v != 28) {
      return (address(0));
    } else {
      return ecrecover(hash, v, r, s);
    }
  }

  function GET_AUTHREQUEST_PACKETHASH (AuthRequest memory _input) public pure returns (bytes32) {
    
    bytes memory encoded = abi.encode(
      AUTHREQUEST_TYPEHASH,
      _input.prompt,
      _input.createdAt,
      _input.id
    );
    
    return keccak256(encoded);
  }

}


contract VerifyAuthSignature is EIP712Decoder  {
  string _name;
  string _version;
  
  constructor (string memory contractName, string memory version) {
    _name = contractName;
    _version = version;
  }

  function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {
    bytes memory encoded = abi.encode(
      EIP712DOMAIN_TYPEHASH,
      keccak256(bytes(contractName)),
      keccak256(bytes(version)),
      chainId,
      verifyingContract
    );
    return keccak256(encoded);
  }


  function getAuthRequestTypedDataHash(AuthRequest memory authRequest, bytes32 domainHash) public pure returns (bytes32) {
    bytes32 digest = keccak256(abi.encodePacked(
      "\x19\x01",

      // The domainHash is derived from your contract name and address above:
      domainHash,

      // This last part is calling one of the generated methods.
      // It must match the name of the struct that is the `primaryType` of this signature.
      GET_AUTHREQUEST_PACKETHASH(authRequest)
    ));
    return digest;
  }

  function verifyAuthRequestSignature (AuthRequest memory authRequest, bytes memory signature, uint256 chainId ) public view returns (address) {
    bytes32 domainHash = getEIP712DomainHash(_name, _version,chainId, address(this));
    // Get the top-level hash of that struct, as defined just below:
    bytes32 sigHash = getAuthRequestTypedDataHash(authRequest, domainHash);

    // The `recover` method comes from the codegen, and will be able to recover from this:
    address recoveredSignatureSigner = recover(sigHash, signature);
    return recoveredSignatureSigner;
  }
}