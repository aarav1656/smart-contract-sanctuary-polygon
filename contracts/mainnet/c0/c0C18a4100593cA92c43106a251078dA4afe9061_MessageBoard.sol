/**
 *Submitted for verification at polygonscan.com on 2023-04-04
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : MsgBoard
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract MessageBoard {

	address owner;
	struct aMessage { uint256 msgId; uint256 catId; string message; address userName; uint256 messageCoinPrice0; }
	struct aCategory { uint256 catId; bool isTheCategoryAlreadyAdded; uint256 categoryCoinPrice0; uint256 messageCoinPrice0; }
	mapping(string => aCategory) public categoriesInfo;
	string[] public categoriesList;
	aMessage[] public messagesList;
	uint256 public categoryCoinPrice0 = uint256(100000000000000000000);
	uint256 public categoryCoinPrice0SourceAmtInBank = uint256(0);
	uint256 public messageCoinPrice0 = uint256(3000000000000000000);
	uint256 public messageCoinPrice0SourceAmtInBank = uint256(0);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	

/**
 * This function allows the owner to change the value of messageCoinPrice0.
 * Notes for _messageCoinPrice0 : 10^18 represents 1 UChildERC20Proxy0
*/
	function changeValueOf_messageCoinPrice0 (uint256 _messageCoinPrice0) external onlyOwner {
		 messageCoinPrice0 = _messageCoinPrice0;
	}

/**
 * Function addCategory
 * The function takes in 1 variable, (a string) catName. It can only be called by functions outside of this contract. It does the following :
 * checks that (categoriesInfo with element catName with element isTheCategoryAlreadyAdded) is equals to false
 * calls ERC20(Address 0xA934bcBf24A7272781197b6559230c30bf0BB2e6)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as categoryCoinPrice0
 * updates categoryCoinPrice0SourceAmtInBank as (categoryCoinPrice0SourceAmtInBank) + (categoryCoinPrice0)
 * creates an internal variable nosCategories with initial value length of categoriesList
 * adds catName to categoriesList
 * updates categoriesInfo (Element catName) as Struct comprising nosCategories, true, categoryCoinPrice0, 0
*/
	function addCategory(string memory catName) external {
		require((categoriesInfo[catName].isTheCategoryAlreadyAdded == false), "Category already registered");
		ERC20(address(0xA934bcBf24A7272781197b6559230c30bf0BB2e6)).transferFrom(msg.sender, address(this), categoryCoinPrice0);
		categoryCoinPrice0SourceAmtInBank  = (categoryCoinPrice0SourceAmtInBank + categoryCoinPrice0);
		uint256 nosCategories = (categoriesList).length;
		categoriesList.push(catName);
		categoriesInfo[catName]  = aCategory (nosCategories, true, categoryCoinPrice0, uint256(0));
	}

/**
 * Function addMessage
 * The function takes in 2 variables, (a string) catName, and (a string) message. It can only be called by functions outside of this contract. It does the following :
 * creates an internal variable thisCategory with initial value categoriesInfo with element catName
 * checks that (thisCategory with element isTheCategoryAlreadyAdded) is equals to true
 * calls ERC20(Address 0xA934bcBf24A7272781197b6559230c30bf0BB2e6)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as messageCoinPrice0
 * updates messageCoinPrice0SourceAmtInBank as (messageCoinPrice0SourceAmtInBank) + (messageCoinPrice0)
 * updates categoriesInfo (Element catName) as thisCategory
 * creates an internal variable nosMessages with initial value length of messagesList
 * creates an internal variable messagesContent with initial value Struct comprising nosMessages, (thisCategory with element catId), message, (the address that called this function), messageCoinPrice0
 * adds messagesContent to messagesList
*/
	function addMessage(string memory catName, string memory message) external {
		aCategory memory thisCategory = categoriesInfo[catName];
		require((thisCategory.isTheCategoryAlreadyAdded == true), "Category not yet registered");
		ERC20(address(0xA934bcBf24A7272781197b6559230c30bf0BB2e6)).transferFrom(msg.sender, address(this), messageCoinPrice0);
		messageCoinPrice0SourceAmtInBank  = (messageCoinPrice0SourceAmtInBank + messageCoinPrice0);
		categoriesInfo[catName]  = thisCategory;
		uint256 nosMessages = (messagesList).length;
		aMessage memory messagesContent = aMessage (nosMessages, thisCategory.catId, message, msg.sender, messageCoinPrice0);
		messagesList.push(messagesContent);
	}

/**
 * Function categoryCoinPrice0SourceWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xA934bcBf24A7272781197b6559230c30bf0BB2e6)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to categoryCoinPrice0SourceAmtInBank
 * calls ERC20(Address 0xA934bcBf24A7272781197b6559230c30bf0BB2e6)'s at transfer function  with variable recipient as (the address that called this function), variable amount as categoryCoinPrice0SourceAmtInBank
 * updates categoryCoinPrice0SourceAmtInBank as 0
*/
	function categoryCoinPrice0SourceWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xA934bcBf24A7272781197b6559230c30bf0BB2e6)).balanceOf(address(this)) >= categoryCoinPrice0SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		ERC20(address(0xA934bcBf24A7272781197b6559230c30bf0BB2e6)).transfer(msg.sender, categoryCoinPrice0SourceAmtInBank);
		categoryCoinPrice0SourceAmtInBank  = uint256(0);
	}

/**
 * Function messageCoinPrice0SourceWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xA934bcBf24A7272781197b6559230c30bf0BB2e6)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to messageCoinPrice0SourceAmtInBank
 * calls ERC20(Address 0xA934bcBf24A7272781197b6559230c30bf0BB2e6)'s at transfer function  with variable recipient as (the address that called this function), variable amount as messageCoinPrice0SourceAmtInBank
 * updates messageCoinPrice0SourceAmtInBank as 0
*/
	function messageCoinPrice0SourceWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xA934bcBf24A7272781197b6559230c30bf0BB2e6)).balanceOf(address(this)) >= messageCoinPrice0SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		ERC20(address(0xA934bcBf24A7272781197b6559230c30bf0BB2e6)).transfer(msg.sender, messageCoinPrice0SourceAmtInBank);
		messageCoinPrice0SourceAmtInBank  = uint256(0);
	}
}