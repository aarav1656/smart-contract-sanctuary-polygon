/**
 *Submitted for verification at polygonscan.com on 2023-04-15
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Lottery
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface ERC721{
	function ownerOf(uint256 tokenId) external view returns (address);
	function totalSupply() external view returns (uint256);
}

contract Lottery {

	mapping(uint256 => uint256) public receipients;
	bool public lotteryRun = false;
	uint256[2][1] public prizeList = [[uint256(1), uint256(4)]];

	function random(uint256 input) internal view returns (uint256) {
		return
			uint256(
				keccak256(
					abi.encodePacked(
						block.timestamp +
							block.difficulty +
							block.gaslimit +
							block.number +
							input +
							((
								uint256(
									keccak256(abi.encodePacked(block.coinbase))
								)
							) / block.timestamp) 
							
					)
				)
			);
	}

/**
 * Function runLottery
 * The function takes in 1 variable, (zero or a positive integer) _nosTokens. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (_nosTokens modulo 4) is equals to 0
 * calls ERC20(Address 0xAa4e4f2247758f46833704f91CAfe1a185D52cd6)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _nosTokens
 * checks that not lotteryRun
 * creates an internal variable totalSupply with initial value ERC721(Address 0xeEb9549ccC7C74f10E6420D25aE5D4aa4489972c)'s at totalSupply function 
 * creates an internal variable counter with initial value 0
 * repeat 1 time with loop variable i0 :  (creates an internal variable share with initial value prizeList with element Loop Variable i0 with element 0; then creates an internal variable nosWinners with initial value prizeList with element Loop Variable i0 with element 1; and then repeat nosWinners times with loop variable i1 :  (creates an internal variable winningTokenID with initial value randomGenerator with variable seed as counter, variable totalSupply as totalSupply; then creates an internal variable amtWon with initial value ((_nosTokens) * (share)) / (4); then updates receipients (Element winningTokenID) as amtWon; then creates an internal variable ownerOfToken with initial value ERC721(Address 0xeEb9549ccC7C74f10E6420D25aE5D4aa4489972c)'s at ownerOf function  with variable tokenId as winningTokenID; then checks that (ERC20(Address 0xAa4e4f2247758f46833704f91CAfe1a185D52cd6)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to amtWon; then if amtWon is strictly greater than 0 then (calls ERC20(Address 0xAa4e4f2247758f46833704f91CAfe1a185D52cd6)'s at transfer function  with variable recipient as ownerOfToken, variable amount as amtWon); and then updates counter as (counter) + (10)))
 * updates lotteryRun as true
*/
	function runLottery(uint256 _nosTokens) public {
		require(((_nosTokens % uint256(4)) == uint256(0)), "Value not visible by 4");
		ERC20(address(0xAa4e4f2247758f46833704f91CAfe1a185D52cd6)).transferFrom(msg.sender, address(this), _nosTokens);
		require(!(lotteryRun), "Lottery has already been run");
		uint256 totalSupply = ERC721(address(0xeEb9549ccC7C74f10E6420D25aE5D4aa4489972c)).totalSupply();
		uint256 counter = uint256(0);
		for (uint i0 = 0; i0 < uint256(1); i0++){
			uint256 share = prizeList[i0][uint256(0)];
			uint256 nosWinners = prizeList[i0][uint256(1)];
			for (uint i1 = 0; i1 < nosWinners; i1++){
				uint256 winningTokenID = randomGenerator(counter, totalSupply);
				uint256 amtWon = ((_nosTokens * share) / uint256(4));
				receipients[winningTokenID]  = amtWon;
				address ownerOfToken = ERC721(address(0xeEb9549ccC7C74f10E6420D25aE5D4aa4489972c)).ownerOf(winningTokenID);
				require((ERC20(address(0xAa4e4f2247758f46833704f91CAfe1a185D52cd6)).balanceOf(address(this)) >= amtWon), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
				if ((amtWon > uint256(0))){
					ERC20(address(0xAa4e4f2247758f46833704f91CAfe1a185D52cd6)).transfer(ownerOfToken, amtWon);
				}
				counter  = (counter + uint256(10));
			}
		}
		lotteryRun  = true;
	}

/**
 * Function randomGenerator
 * The function takes in 2 variables, (zero or a positive integer) seed, and (zero or a positive integer) totalSupply. It can only be called by other functions in this contract. It does the following :
 * creates an internal variable candidateVariable with initial value (random number with seed seed) modulo totalSupply
 * if 0 is equals to (receipients with element candidateVariable) then (returns candidateVariable as output) otherwise (returns randomGenerator with variable seed as ((seed) + (1)), variable totalSupply as totalSupply as output)
*/
	function randomGenerator(uint256 seed, uint256 totalSupply) internal view returns (uint256) {
		uint256 candidateVariable = (random(seed) % totalSupply);
		if ((uint256(0) == receipients[candidateVariable])){
			return candidateVariable;
		}else{
			return randomGenerator((seed + uint256(1)), totalSupply);
		}
	}
}