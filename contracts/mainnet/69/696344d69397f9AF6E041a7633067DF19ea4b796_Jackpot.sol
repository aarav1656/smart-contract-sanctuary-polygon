/**
 *Submitted for verification at polygonscan.com on 2023-04-28
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Jackpot
*/

contract Jackpot {

	address owner;
	bool public paused = false;
	address[] public players;
	address[] public winners;
	uint256 public jackpotNativePrice = uint256(3000000000000000000);
	uint256 public jackpotNativePriceSourceAmtInBank = uint256(0);
	uint256 public retainedForJackpotNative = uint256(0);
	event JackpotEntered (address indexed participatingAddress, uint256 indexed participationNumber);
	event JackpotDone (address indexed winningAddress);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function random(uint256 input) internal view returns (uint256) {
		return
			uint256(
				keccak256(
					abi.encodePacked(
						block.timestamp +
							block.difficulty +
							block.gaslimit +
							block.number +
							input +
							((
								uint256(
									keccak256(abi.encodePacked(block.coinbase))
								)
							) / block.timestamp) 
							
					)
				)
			);
	}

/**
 * Function changeValueOf_paused
 * Notes for _paused : Toggle to pause lottery
 * The function takes in 1 variable, (a boolean) _paused. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates paused as _paused
*/
	function changeValueOf_paused(bool _paused) external onlyOwner {
		paused  = _paused;
	}

/**
 * Function jackpotNativePriceSourceTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to jackpotNativePriceSourceAmtInBank
 * if jackpotNativePriceSourceAmtInBank is strictly greater than 0 then (transfers jackpotNativePriceSourceAmtInBank of the native currency to the address that called this function)
 * updates jackpotNativePriceSourceAmtInBank as 0
*/
	function jackpotNativePriceSourceTaxWithdrawAmt() public onlyOwner {
		require((address(this).balance >= jackpotNativePriceSourceAmtInBank), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((jackpotNativePriceSourceAmtInBank > uint256(0))){
			payable(msg.sender).transfer(jackpotNativePriceSourceAmtInBank);
		}
		jackpotNativePriceSourceAmtInBank  = uint256(0);
	}

/**
 * Function playJackpot
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * checks that not paused
 * checks that (amount of native currency sent to contract) is equals to jackpotNativePrice
 * updates jackpotNativePriceSourceAmtInBank as (jackpotNativePriceSourceAmtInBank) + (((amount of native currency sent to contract) * (5)) / (10))
 * updates retainedForJackpotNative as (retainedForJackpotNative) + (((amount of native currency sent to contract) * ((1000000) - (500000))) / (1000000))
 * adds the address that called this function to players
 * emits event JackpotEntered with inputs the address that called this function, length of players
*/
	function playJackpot() external payable {
		require(!(paused), "Jackpot currently paused by owner");
		require((msg.value == jackpotNativePrice), "Incorrect Payment");
		jackpotNativePriceSourceAmtInBank  = (jackpotNativePriceSourceAmtInBank + ((msg.value * uint256(5)) / uint256(10)));
		retainedForJackpotNative  = (retainedForJackpotNative + ((msg.value * (uint256(1000000) - uint256(500000))) / uint256(1000000)));
		players.push(msg.sender);
		emit JackpotEntered(msg.sender, (players).length);
	}

/**
 * Function triggerWinning
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (length of players) is strictly greater than 0
 * creates an internal variable winningAddress with initial value players with element (random number with seed (length of players)) modulo (length of players)
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to retainedForJackpotNative
 * if retainedForJackpotNative is strictly greater than 0 then (transfers retainedForJackpotNative of the native currency to winningAddress)
 * updates retainedForJackpotNative as 0
 * updates players as Empty List
 * adds winningAddress to winners
 * emits event JackpotDone with inputs winningAddress
*/
	function triggerWinning() external onlyOwner {
		require(((players).length > uint256(0)), "0 players in jackpot");
		address winningAddress = players[(random((players).length) % (players).length)];
		require((address(this).balance >= retainedForJackpotNative), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((retainedForJackpotNative > uint256(0))){
			payable(winningAddress).transfer(retainedForJackpotNative);
		}
		retainedForJackpotNative  = uint256(0);
		players  = new address[](0);
		winners.push(winningAddress);
		emit JackpotDone(winningAddress);
	}
}